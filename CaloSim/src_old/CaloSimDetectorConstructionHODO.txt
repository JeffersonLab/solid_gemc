//
// ********************************************************************
// * DISCLAIMER                                                       *
// *                                                                  *
// * The following disclaimer summarizes all the specific disclaimers *
// * of contributors to this software. The specific disclaimers,which *
// * govern, are listed with their locations in:                      *
// *   http://cern.ch/geant4/license                                  *
// *                                                                  *
// * Neither the authors of this software system, nor their employing *
// * institutes,nor the agencies providing financial support for this *
// * work  make  any representation or  warranty, express or implied, *
// * regarding  this  software system or assume any liability for its *
// * use.                                                             *
// *                                                                  *
// * This  code  implementation is the  intellectual property  of the *
// * GEANT4 collaboration.                                            *
// * By copying,  distributing  or modifying the Program (or any work *
// * based  on  the Program)  you indicate  your  acceptance of  this *
// * statement, and all its terms.                                    *
// ********************************************************************
//
//
// $Id: CaloSimDetectorConstruction.cc,v 1.5 2002/01/09 17:23:48 ranjard Exp $
// GEANT4 tag $Name: geant4-04-00-patch-02 $
//

#include "CaloSimDetectorConstruction.hh"
#include "CaloSimSD.hh"

#include "G4Material.hh"
#include "G4Box.hh"
#include "G4Tubs.hh"
#include "G4LogicalVolume.hh"
#include "G4ThreeVector.hh"
#include "G4PVPlacement.hh"
#include "globals.hh"
#include "G4SDManager.hh"

CaloSimDetectorConstruction::CaloSimDetectorConstruction(G4String outputFile)
{
  if(outputFile.isNull()){outputFileName = "output.root";}
  else{outputFileName=outputFile;}
}

CaloSimDetectorConstruction::~CaloSimDetectorConstruction()
{
  /*
  delete calorimeterLayer_log;
  delete calorimeterBlock_log;
  delete tracker_log;
  delete experimentalHall_log;
  delete tracker_phys;
  delete calorimeterBlock_phys;
  delete calorimeterLayer_phys;
  delete experimentalHall_phys;
  */
}

G4VPhysicalVolume* CaloSimDetectorConstruction::Construct()
{

  //------------------------------------------------------ materials

  G4String name;
  

   //--------- Set Visualization Attributes -----------------------
   whiteSolid   = new G4VisAttributes(G4Colour(1,1,1));
   blackSolid   = new G4VisAttributes(G4Colour(0,0,0));
   redSolid     = new G4VisAttributes(G4Colour(1,0,0));
   greenSolid   = new G4VisAttributes(G4Colour(0,1,0));
   blueSolid    = new G4VisAttributes(G4Colour(0,0,1));
   magentaSolid = new G4VisAttributes(G4Colour(1,0,1));
   cyanSolid    = new G4VisAttributes(G4Colour(0,1,1));
   yellowSolid  = new G4VisAttributes(G4Colour(1,1,0));
   whiteFrame   = new G4VisAttributes(G4Colour(1,1,1));
   redFrame     = new G4VisAttributes(G4Colour(1,0,0));
   greenFrame   = new G4VisAttributes(G4Colour(0,1,0));
   blueFrame    = new G4VisAttributes(G4Colour(0,0,1));
   magentaFrame = new G4VisAttributes(G4Colour(1,0,1));
   cyanFrame    = new G4VisAttributes(G4Colour(0,1,1));
   yellowFrame  = new G4VisAttributes(G4Colour(1,1,0));
   offAtt       = new G4VisAttributes();

   whiteSolid->SetForceSolid(true);
   blackSolid->SetForceSolid(true);
   redSolid->SetForceSolid(true);
   greenSolid->SetForceSolid(true);
   blueSolid->SetForceSolid(true);
   magentaSolid->SetForceSolid(true);
   cyanSolid->SetForceSolid(true);
   yellowSolid->SetForceSolid(true);
   whiteFrame->SetForceWireframe(true);
   redFrame->SetForceWireframe(true);
   greenFrame->SetForceWireframe(true);
   blueFrame->SetForceWireframe(true);
   magentaFrame->SetForceWireframe(true);
   cyanFrame->SetForceWireframe(true);
   yellowFrame->SetForceWireframe(true);
   offAtt->SetVisibility(false);
   

  buildMaterials();


  //------------------------------------------------
  // Create Sensitive Detector Manager
  //------------------------------------------------
  
  G4SDManager* SDman = G4SDManager::GetSDMpointer();

  

  G4String SDname = "CaloSim/SD";
  CaloSimSD* aSD = new CaloSimSD( SDname , outputFileName);
  SDman->AddNewDetector( aSD );




  //------------------------------------------------------ volumes

  //------------------------------ experimental hall (world volume)
  //------------------------------ beam line along x axis

  G4double expHall_x = 1.0*m;
  G4double expHall_y = 1.0*m;
  G4double expHall_z = 5.0*m;
  G4Box* experimentalHall_box
    = new G4Box("expHall_box",expHall_x,expHall_y,expHall_z);
  experimentalHall_log = new G4LogicalVolume(experimentalHall_box,
                                             Air,"expHall_log",0,0,0);
  experimentalHall_phys = new G4PVPlacement(0,G4ThreeVector(),"expHall",
                                            experimentalHall_log,0,false,0);

    experimentalHall_log->SetVisAttributes(offAtt); 
  experimentalHall_log->SetSensitiveDetector(aSD);  

  G4ThreeVector positionCaloBox = G4ThreeVector(0,0,0);


  G4double SVertWidth = 1.0*cm;
  G4double SVertHeight = 15.0*cm;
  G4double SVertDepth = 3.0*mm;

  G4double SHorizWidth = 20.0*cm;
  G4double SHorizHeight = 1.0*cm;
  G4double SHorizDepth = 3.0*mm;

  G4double nsV= 20;
  G4double nsH= 15;

  //  G4double blockHeight=4.0*cm;
  // *** Make block 6cm high for prototype test

  // these are the segments
  G4double blockHeight=1.0*cm;

  G4double blockWidth=1.0*cm;
  //  G4double blockDepth=11.0*cm;
  G4double blockDepth=15.0*cm;
  // set divisions in calo
  const G4int nX=20;
  const G4int nY=15;

  G4double caloWidth = blockWidth*nX;
  G4double caloHeight = blockHeight*nY;
  G4double caloDepth = blockDepth;


  // Set up the box containing the calorimeter 
  G4Box* solidCaloBox = new G4Box("caloBox", caloWidth/2, caloHeight/2, caloDepth/2);
  G4LogicalVolume* logicCaloBox = new G4LogicalVolume(solidCaloBox,
                                                      Air,"CaloBoxLV");

  G4VPhysicalVolume* physiCaloBox = new G4PVPlacement(0,positionCaloBox, "CaloBox", logicCaloBox, experimentalHall_phys,false,0);

    logicCaloBox->SetVisAttributes(offAtt);
  logicCaloBox->SetSensitiveDetector(aSD);  


  //  Set up the logical for staves
  G4Box* solidSVert = new G4Box("SVert",SVertWidth/2,SVertHeight/2,SVertDepth/2);
  G4Box* solidSHoriz = new G4Box("SHoriz",SHorizWidth/2,SHorizHeight/2,SHorizDepth/2);  

  G4LogicalVolume* logicSVert = new G4LogicalVolume(solidSVert,BC404,"SVertLV");
  G4LogicalVolume* logicSHoriz = new G4LogicalVolume(solidSHoriz,BC404,"SHorizLV");

  logicSVert->SetVisAttributes(whiteFrame);	
  logicSHoriz->SetVisAttributes(whiteFrame);

  G4VPhysicalVolume* physiSVert[nsV];
  for(G4int xi=0;xi<nsV; xi++){
  G4double xpos = -caloWidth/2 + (0.5+xi)*blockWidth;
  G4double ypos = 0;
  G4double zpos = -8.5*cm;
G4ThreeVector positionSVert = G4ThreeVector(xpos,ypos,zpos);
physiSVert[xi] = G4PVPlacement(0,positionSVert,"SVert",logicSVert,physiSVert,false,xi+1);
}

  G4Box* solidCaloBlock = new G4Box("caloBlock", blockWidth/2, 
				    blockHeight/2, blockDepth/2);



//set up logical for calo box
  G4LogicalVolume* logicCaloBlock = new G4LogicalVolume(solidCaloBlock,
  					      Tungsten,"CaloBlockLV");


    logicCaloBlock->SetVisAttributes(blueFrame);
  logicCaloBlock->SetSensitiveDetector(aSD);  


  G4VPhysicalVolume* physiCaloBlock[nX*nY-1];
  for(G4int xi=0; xi<nX; xi++){
    for(G4int yi=0; yi<nY; yi++){
      G4double xpos = -caloWidth/2 + (0.5+xi)*blockWidth;
      G4double ypos = -caloHeight/2 + (0.5+yi)*blockHeight;

      G4ThreeVector positionCaloBlock = G4ThreeVector(xpos,ypos,0);
    
      
      physiCaloBlock[xi+nX*yi] = new G4PVPlacement(0,positionCaloBlock, "CaloBlock", logicCaloBlock, physiCaloBox,false,xi+yi*nX+1);
      
    }
  }



  // The layers of scintillator/glue
  G4int nlayers=10;
  G4double layerSep=blockWidth/nlayers;
  //  G4double layerThick= 0.5*mm;
  G4double fiberFrac = 0.5;
  G4double layerThick= layerSep*fiberFrac;

  G4Box* solidLayer = new G4Box("Layer", layerThick/2, 
				    blockHeight/2, blockDepth/2);

  // **** TEST WITH TUNGSTEN FIBER
  //  BC404=Tungsten; // TEMPORARY CHANGE TO MAKE CALO ALL TUNGSTEN 4/21
  G4Material *glueTemp = BC404;
  //  G4Material *glueTemp = Tungsten;
  G4LogicalVolume* logicLayer = new G4LogicalVolume(solidLayer,
						    glueTemp, "LayerLV");
    logicLayer->SetVisAttributes(offAtt);
  logicLayer->SetSensitiveDetector(aSD);  



  for(G4int li=0; li<nlayers; li++){
    G4double xPosLayer = -blockWidth/2 + layerSep * (li + 0.5);
    G4ThreeVector positionLayer = G4ThreeVector(xPosLayer,0,0);
    
    G4VPhysicalVolume* physiLayer = new G4PVPlacement(0,positionLayer, logicLayer, "Layer", logicCaloBlock,false,li);
  }

  /* 
  // These are the original fiber specifications modified *incorrectly*
  // for smaller effective fiber diameter (inefficiency on the outside)
  // I'm commenting it out and rewriting it to allow me to do it correctly
  // -Ron McNabb 12/14/08

  // Fibers
  G4double fiberDiameter=layerThick;
  G4int nfibers=blockHeight/fiberDiameter;
  //  G4double fiberSep=fiberDiameter;

  // changed fiber diameter to account for respose 11/8/08
  G4double fiberSep=fiberDiameter*0.94;
  //  G4double fiberSep=blockHeight/nfibers;
  */

  // Fibers (updated 12/14)
  G4double fiberFracSensitive=1.0;// fraction of fiber radius that is sensitive
  G4double fiberSep=layerThick;
  G4double fiberDiameter=fiberSep*fiberFracSensitive;
  G4int nfibers=blockHeight/fiberSep;




  G4Tubs *solidFiber = new G4Tubs("FiberSolid",0.,fiberDiameter/2,
				  blockDepth/2,0.,twopi);

  G4LogicalVolume* logicFiber = new G4LogicalVolume(solidFiber,
  BC404, "FiberLV");

  // ***** TEST WITH TUNGSTEN FIBERS***
  //  G4LogicalVolume* logicFiber = new G4LogicalVolume(solidFiber,
  // 						    Tungsten, "FiberLV");


    logicFiber->SetVisAttributes(redFrame);
  logicFiber->SetSensitiveDetector(aSD);  



  for(G4int fi=0; fi<nfibers; fi++){
    G4double yPosFiber = -blockHeight/2 + fiberSep * (fi + 0.5);
    G4ThreeVector positionFiber = G4ThreeVector(0,yPosFiber,0);

    G4VPhysicalVolume* physiFiber = new G4PVPlacement(0,positionFiber, 
						      logicFiber, "Fiber", 
						      logicLayer,false,fi);
  }




  return experimentalHall_phys;
}

