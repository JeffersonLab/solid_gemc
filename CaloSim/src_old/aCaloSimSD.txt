
// $Id: CaloSimSD.cc,v 1.38 2004/04/09 19:02:20 asharp Exp $
// GEANT4 tag $Name:  $
//
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.....
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.....

#include "CaloSimSD.hh"
// #include "MulanRunAction.hh"
// #include "MulanPrimaryGeneratorAction.hh"
// #include "MulanEventAction.hh"
#include "G4HCofThisEvent.hh"
#include "G4THitsCollection.hh"
#include "G4ParticleDefinition.hh"
#include "G4Step.hh"
#include "G4ThreeVector.hh"
#include "G4SDManager.hh"
#include "G4ios.hh"
#include "G4VProcess.hh"
#include "G4String.hh"
#include "stdio.h"
#include "math.h"
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.....

CaloSimSD::CaloSimSD(G4String name, G4String outputFileName=NULL):G4VSensitiveDetector(name)
{
  G4cout<<"CaloSimSD instantiating...";
  G4String HCname = name;
  collectionName.insert(HCname="detectorCollection");

  //  outfile=fopen("tmp.dat", "w");

  G4cout<<" done"<<G4endl;

  //  G4String outputFileName="test.root";
  rootFile = new TFile(outputFileName, "RECREATE");


  ntuple = new TNtuple("ntuple","ROOT Ntuple for G4 data", 
		       "evtIndex:vtxE:initX:initY:initZ:caloX:caloY:caloZ:initPX:initPY:initPZ:caloEdep:fiberEdep:glueEdep:WEdep:b000:b001:b002:b003:b004:b005:b006:b007:b008:b009:b010:b011:b012:b013:b014:b015:b016:b017:b018:b019:b020:b021:b022:b023:b024:b025:b026:b027:b028:b029:b030:b031:b032:b033:b034:b035:b036:b037:b038:b039:b040:b041:b042:b043:b044:b045:b046:b047:b048:b049:b050:b051:b052:b053:b054:b055:b056:b057:b058:b059:b060:b061:b062:b063:b064:b065:b066:b067:b068:b069:b070:b071:b072:b073:b074:b075:b076:b077:b078:b079:b080:b081:b082:b083:b084:b085:b086:b087:b088:b089:b090:b091:b092:b093:b094:b095:b096:b097:b098:b099:b100:b101:b102:b103:b104:b105:b106:b107:b108:b109:b110:b111:b112:b113:b114:b115:b116:b117:b118:b119:b120:b121:b122:b123:b124:b125:b126:b127:b128:b129:b130:b131:b132:b133:b134:b135:b136:b137:b138:b139:b140:b141:b142:b143:b144:b145:b146:b147:b148:b149:b150:b151:b152:b153:b154:b155:b156:b157:b158:b159:b160:b161:b162:b163:b164:b165:b166:b167:b168:b169:b170:b171:b172:b173:b174:b175:b176:b177:b178:b179:b180:b181:b182:b183:b184:b185:b186:b187:b188:b189:b190:b191:b192:b193:b194:b195:b196:b197:b198:b199:b200:b201:b202:b203:b204:b205:b206:b207:b208:b209:b210:b211:b212:b213:b214:b215:b216:b217:b218:b219:b220:b221:b222:b223:b224:b225:b226:b227:b228:b229:b230:b231:b232:b233:b234:b235:b236:b237:b238:b239:b240:b241:b242:b243:b244:b245:b246:b247:b248:b249:b250:b251:b252:b253:b254:b255:b256:b257:b258:b259:b260:b261:b262:b263:b264:b265:b266:b267:b268:b269:b270:b271:b272:b273:b274:b275:b276:b277:b278:b279:b280:b281:b282:b283:b284:b285:b286:b287:b288:b289:b290:b291:b292:b293:b294:b295:b296:b297:b298:b299:v00:v01:v02:v03:v04:v05:v06:v07:v08:v09:v10:v11:v12:v13:v14:h00:h01:h02:h03:h04:h05:h06:h07:h08:h09:h10:h11:h12:h13:h14:totalEdep:diffX:diffY:diffZ:startOut");

  G4int xbins=200;
  G4double xmax=200.; 
  Int_t ybins=320;
  G4double ymax=160; 
  EvsFiber=new TH2D("EvsFiber", "EvsFiber", xbins, 0, xmax, ybins, 0, ymax);


  evtIndex = -1;

}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.....

CaloSimSD::~CaloSimSD()
{ 

  //printf("\n\n CLOSING \n\n");
  //  fclose(outfile);
  rootFile->Write();
  rootFile->Close();


  //G4cout<<"This is CaloSimSD destructor\n";
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.....

void CaloSimSD::Initialize(G4HCofThisEvent* HCE)
{
  detectorCollection = new CaloSimHitsCollection(SensitiveDetectorName,collectionName[0]); 
  static G4int HCID = -1;
  if(HCID<0)
  { 
    HCID = G4SDManager::GetSDMpointer()->GetCollectionID(collectionName[0]);
  }
  HCE->AddHitsCollection( HCID, detectorCollection ); 
  // resetting variables to be used in each step
  badFirstStep = 0;
  evtIndex++; // events counter starts at 0.
  Prim4VecSet = false;

  fEnteredCalo=0;
  


}
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.....

G4bool CaloSimSD::ProcessHits(G4Step* aStep,
				    G4TouchableHistory* ROhist)
{
  /////////////////////////////////////////////////////////////////////
  // This function is called when a particle takes a step in a       //
  // sensitive volume. It looks up relevant information about the    //
  // particle, its location, what it's doing, etc. and stores it in a//
  // CaloSimHit object (a new instance of it called newHit is  //
  // made each time). This information is recovered later when       //
  // EndOfEvent() is called. If you want to look at the info while   // 
  // it's stored in the hit collection (a vector of CaloSimHit //
  // objects compiled for each event), use the methods of the class  //
  // CaloSimHit, like Print().                                 //
  /////////////////////////////////////////////////////////////////////

  if(badFirstStep == 1) return false;
  particleName = aStep->GetTrack()->GetDefinition()->GetParticleName();


  parentID = aStep->GetTrack()->GetParentID();
  currentVolume = aStep->GetPreStepPoint()->GetPhysicalVolume();
  volumeName = currentVolume->GetName();
  const G4VProcess* stepProcess=aStep->GetPostStepPoint()->GetProcessDefinedStep();
  G4String stepProcessName = "None";
  if(stepProcess != NULL) {stepProcessName = stepProcess->GetProcessName();}
  const G4VProcess* creatorProcess = aStep->GetTrack()->GetCreatorProcess();
  G4String creatorProcessName = "None";
  if(creatorProcess != NULL) {
    creatorProcessName = creatorProcess->GetProcessName();
  }
  CaloSimDetectorHit* newHit = new CaloSimDetectorHit();
  // these numbers we know right away
  newHit->SetTrackNumber(aStep->GetTrack()->GetTrackID());
  newHit->SetEdep(aStep->GetTotalEnergyDeposit());
  newHit->SetParticleMom(aStep->GetPreStepPoint()->GetMomentum());
  newHit->SetHitPosition(aStep->GetPreStepPoint()->GetPosition());
  newHit->SetHitVol(volumeName);
  newHit->SetParticleEnergy(aStep->GetTrack()->GetKineticEnergy());
  newHit->SetVertexPos(aStep->GetTrack()->GetVertexPosition());


  // set the names of process used in this step, and 
  // process that created the current particle
  newHit->SetStepProcName(stepProcessName);
  if(creatorProcess!=NULL) {
    G4String *creator = &creatorProcessName;
    newHit->SetCreatorProcName(*creator);
  }
  else {newHit->SetCreatorProcName(creatorProcessName);}


  newHit->SetVertexMom(aStep->GetTrack()->GetVertexMomentumDirection());
  newHit->SetVertexEnergy(aStep->GetTrack()->GetVertexKineticEnergy());

  G4int hitSVert=0;
  G4int hitSHoriz=0;
  G4int hitBlock=0;
  G4int hitLayer=0;
  G4int hitFiber=0;
  if(!strcmp(volumeName,"Fiber")) {

    hitBlock =
      aStep->GetPreStepPoint()->GetTouchable()->GetReplicaNumber(2);
    hitLayer =
      aStep->GetPreStepPoint()->GetTouchable()->GetReplicaNumber(1);
    hitFiber =
      aStep->GetPreStepPoint()->GetTouchable()->GetReplicaNumber(0);

  }

  if(!strcmp(volumeName,"Layer")) {

    hitBlock =
      aStep->GetPreStepPoint()->GetTouchable()->GetReplicaNumber(1);
    hitLayer =
      aStep->GetPreStepPoint()->GetTouchable()->GetReplicaNumber(0);

    //   G4cout<< volumeName << "  LAYER: " << hitLayer << " FIBER: " << hitFiber
    //	<< "  BLOCK: "  << hitBlock << G4endl;

  }

  if(!strcmp(volumeName,"SVert")){
    hitSVert = 
      aStep->GetPreStepPoint()->GetTouchable()->GetReplicaNumber(0);
  }

    if(!strcmp(volumeName,"SHoriz")){
    hitSHoriz = 
      aStep->GetPreStepPoint()->GetTouchable()->GetReplicaNumber(0);
  }

  

    newHit->SetSVert(hitSVert);
    newHit->SetSHoriz(hitSHoriz);
  newHit->SetBlock(hitBlock);
  newHit->SetLayer(hitLayer);
  newHit->SetFiber(hitFiber);



  // calculate the particle type number
  G4int type = GetParticleType(particleName, parentID);
  newHit->SetParticleType(type);


  detectorCollection->insert(newHit);

  return true;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo.....

void CaloSimSD::EndOfEvent(G4HCofThisEvent* HCE)
{
  ////////////////////////////////////////////////////////////////////
  // This function is called when each Event has completed (i.e., a //
  // primary muon is generated and tracked, then all of its daughter//
  // and granddaughter particles are tracked). It sets the event    //
  // number index in the tree, then calls ProcessEventHC() to fill  //
  // other leaves and branches in the tree.                         //
  ////////////////////////////////////////////////////////////////////

  // evtIndex is incremented in Initialize() fcn. Starts with 0, not 1.
  if(G4double(G4int(evtIndex/100)) == (evtIndex/100.)) 
    G4cout<<"Doing ProcessEventHC on event "<<evtIndex<<G4endl;

  ProcessEventHC(HCE);
}

void CaloSimSD::ProcessEventHC(G4HCofThisEvent* hitCollections)
{
  //////////////////////////////////////////////////////////////////////
  // Called from EndOfEvent(). Does the processing on each of the hit //
  // collections for each event. There is 1 hit collection for each   //
  // sensitive detector declared in CaloSimConstruction. Each   //
  // hit collection is a vector of CaloSimHit objects containing//
  // relevant information about the steps of each particle within a   //
  // sensitive volume. Retrieves information from the CaloSimHit//
  // objects and stores into branches/leaves of DataTree.             //
  //////////////////////////////////////////////////////////////////////

  G4double totalEdep = 0;
  G4double fiberEdep = 0;
  G4double glueEdep = 0;
  G4double WEdep = 0;
  G4double b[300]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
  }; 
  G4double h[15]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
  G4double v[15]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};




  CaloSimHitsCollection *aHitCollWithinThisEvent;

  // loop over the Hit Collections (1 for each SD in DetConstruction)
  G4int NCollections = hitCollections->GetNumberOfCollections();
  for(G4int n = 0; n < NCollections; n++) {
    aHitCollWithinThisEvent = (CaloSimHitsCollection*) 
      hitCollections->GetHC(n);
    G4int EntriesWithinHitColl = aHitCollWithinThisEvent->entries();
    
    // loop over the hits within the hit collections
    for(G4int ent = 0; ent < EntriesWithinHitColl; ent++) {
      //    G4cout<<"Starting entry "<<ent<<" of "<<EntriesWithinHitColl<<G4endl;
      G4int thisType = (*aHitCollWithinThisEvent)[ent]->GetParticleType();
      G4String thisProcess = (*aHitCollWithinThisEvent)[ent]->GetStepProcName();
      G4String thisVolume = (*aHitCollWithinThisEvent)[ent]->GetHitVolName();
      G4int trackID = (*aHitCollWithinThisEvent)[ent]->GetTrackNumber();

      G4double edep = (*aHitCollWithinThisEvent)[ent]->GetEdep();

      if(!strcmp(thisVolume,"Layer")) {
	glueEdep=glueEdep+edep;
	totalEdep=totalEdep+edep;
      }
      if(!strcmp(thisVolume,"CaloBlock")) WEdep=WEdep+edep;
      if(!strcmp(thisVolume,"Fiber")) {
	fiberEdep=fiberEdep+edep;
	totalEdep=totalEdep+edep;
      }

      G4int sv = 0;
      if(trackID != 1 && !strcmp(thisVolume,"SVert")){
	sv=(*aHitCollWithinThisEvent)[ent]->GetSVert();
	//v[sv-1]= v[sv-1] + edep;
	v[sv-1]+=1;
	//G4cout<<"Vert "<<sv<<G4endl;
      }

      G4int sh = 0;
      if(trackID != 1 && !strcmp(thisVolume,"SHoriz")){
	sh=(*aHitCollWithinThisEvent)[ent]->GetSHoriz();
	//G4cout<<"horiz "<<sh<<G4endl;
	//h[sh-1]= h[sh-1]+edep;
	h[sh-1]+=1;
	//	G4cout<<h[sh-1]/GeV<<G4endl;
      }

      G4int block=0;
      //if(!strcmp(thisVolume,"Fiber") || !strcmp(thisVolume,"Layer")){
      if(!strcmp(thisVolume,"Fiber")){  // Use only the fiber energy
	block=(*aHitCollWithinThisEvent)[ent]->GetBlock();
	b[block-1] = b[block-1] + edep;

	//G4cout << "block = "  << block << "\n"; 
	//G4cout << thisVolume << " " << edep << " " << block << "\n";
      }
      

      

      // histogram fiber energy
      G4int layer=0;
      G4int fiber=0;
      if(!strcmp(thisVolume,"Fiber")){
	block=(*aHitCollWithinThisEvent)[ent]->GetBlock();
	layer=(*aHitCollWithinThisEvent)[ent]->GetLayer();
	fiber=(*aHitCollWithinThisEvent)[ent]->GetFiber();

	G4int blockY=(block-1)/5;
	G4int blockX=(block-1)-(blockY*5);
	G4int fx=40*blockX + layer; 
	G4int fy=80*blockY + fiber; 

	EvsFiber->SetBinContent(fx, fy, edep+EvsFiber->GetBinContent(fx, fy));
	
      }


      totalEdep=totalEdep+edep;

      if(trackID==1  && !Prim4VecSet) {
	vtxPos = (*aHitCollWithinThisEvent)[ent]->GetVertexPos();
	vtxMom = (*aHitCollWithinThisEvent)[ent]->GetVertexMom();

	vtxE = (*aHitCollWithinThisEvent)[ent]->GetVertexEnergy();
	if(vtxE<1e-10) vtxE = 0.0; // truncate very small numbers
	fStartOut=0;
	if(!strcmp(thisVolume,"expHall")) fStartOut=1;
	Prim4VecSet = true;  // flag to say this info recorded once
      }

      /* if(strcmp(thisVolume,"expHall")&&!fEnteredCalo){
	caloPos = (*aHitCollWithinThisEvent)[ent]->GetVertexPos();
	}*/

      if(trackID == 1 && ( !strcmp(thisVolume,"CaloBlock") || !strcmp(thisVolume,"Layer") || !strcmp(thisVolume,"Fiber")) && !fEnteredCalo){
	
	//G4cout<<thisVolume<<G4endl;
	caloPos = (*aHitCollWithinThisEvent)[ent]->GetHitPosition();
	diffPos=caloPos-vtxPos;
	fEnteredCalo=1;
      }



    }

  }


  G4double caloX=caloPos.x();
  G4double caloY=caloPos.y();
  G4double caloZ=caloPos.z();
  //G4cout<<"X= "<<caloX/cm<<"   Y= "<<caloY/cm<<"   Z= "<<caloZ/cm<<G4endl;



  G4double initX=vtxPos.x();
  G4double initY=vtxPos.y();
  G4double initZ=vtxPos.z();
  G4double initPX=vtxMom.x();
  G4double initPY=vtxMom.y();
  G4double initPZ=vtxMom.z();

  G4double diffX=diffPos.x();
  G4double diffY=diffPos.y();
  G4double diffZ=diffPos.z();


  G4double caloEdep=fiberEdep+glueEdep+WEdep;

  Float_t ntpars[400]={evtIndex, vtxE/GeV, initX/cm, initY/cm, initZ/cm, caloX/cm, caloY/cm, caloZ/cm,
		       initPX, initPY, initPZ, caloEdep/GeV,fiberEdep/GeV,glueEdep/GeV,WEdep/GeV,
		      b[0]/GeV, b[1]/GeV, b[2]/GeV, b[3]/GeV, b[4]/GeV, b[5]/GeV, b[6]/GeV, b[7]/GeV, b[8]/GeV, b[9]/GeV, 
		      b[10]/GeV, b[11]/GeV, b[12]/GeV, b[13]/GeV, b[14]/GeV, b[15]/GeV, b[16]/GeV, b[17]/GeV, b[18]/GeV, b[19]/GeV, 
		      b[20]/GeV, b[21]/GeV, b[22]/GeV, b[23]/GeV, b[24]/GeV, b[25]/GeV, b[26]/GeV, b[27]/GeV, b[28]/GeV, b[29]/GeV, 
		      b[30]/GeV, b[31]/GeV, b[32]/GeV, b[33]/GeV, b[34]/GeV, b[35]/GeV, b[36]/GeV, b[37]/GeV, b[38]/GeV, b[39]/GeV, 
		      b[40]/GeV, b[41]/GeV, b[42]/GeV, b[43]/GeV, b[44]/GeV, b[45]/GeV, b[46]/GeV, b[47]/GeV, b[48]/GeV, b[49]/GeV, 
		      b[50]/GeV, b[51]/GeV, b[52]/GeV, b[53]/GeV, b[54]/GeV, b[55]/GeV, b[56]/GeV, b[57]/GeV, b[58]/GeV, b[59]/GeV, 
		      b[60]/GeV, b[61]/GeV, b[62]/GeV, b[63]/GeV, b[64]/GeV, b[65]/GeV, b[66]/GeV, b[67]/GeV, b[68]/GeV, b[69]/GeV, 
		      b[70]/GeV, b[71]/GeV, b[72]/GeV, b[73]/GeV, b[74]/GeV, b[75]/GeV, b[76]/GeV, b[77]/GeV, b[78]/GeV, b[79]/GeV, 
		      b[80]/GeV, b[81]/GeV, b[82]/GeV, b[83]/GeV, b[84]/GeV, b[85]/GeV, b[86]/GeV, b[87]/GeV, b[88]/GeV, b[89]/GeV, 
		      b[90]/GeV, b[91]/GeV, b[92]/GeV, b[93]/GeV, b[94]/GeV, b[95]/GeV, b[96]/GeV, b[97]/GeV, b[98]/GeV, b[99]/GeV, 
		      b[100]/GeV, b[101]/GeV, b[102]/GeV, b[103]/GeV, b[104]/GeV, b[105]/GeV, b[106]/GeV, b[107]/GeV, b[108]/GeV, b[109]/GeV, 
		      b[110]/GeV, b[111]/GeV, b[112]/GeV, b[113]/GeV, b[114]/GeV, b[115]/GeV, b[116]/GeV, b[117]/GeV, b[118]/GeV, b[119]/GeV, 
		      b[120]/GeV, b[121]/GeV, b[122]/GeV, b[123]/GeV, b[124]/GeV, b[125]/GeV, b[126]/GeV, b[127]/GeV, b[128]/GeV, b[129]/GeV, 
		      b[130]/GeV, b[131]/GeV, b[132]/GeV, b[133]/GeV, b[134]/GeV, b[135]/GeV, b[136]/GeV, b[137]/GeV, b[138]/GeV, b[139]/GeV, 
		      b[140]/GeV, b[141]/GeV, b[142]/GeV, b[143]/GeV, b[144]/GeV, b[145]/GeV, b[146]/GeV, b[147]/GeV, b[148]/GeV, b[149]/GeV, 
		      b[150]/GeV, b[151]/GeV, b[152]/GeV, b[153]/GeV, b[154]/GeV, b[155]/GeV, b[156]/GeV, b[157]/GeV, b[158]/GeV, b[159]/GeV, 
		      b[160]/GeV, b[161]/GeV, b[162]/GeV, b[163]/GeV, b[164]/GeV, b[165]/GeV, b[166]/GeV, b[167]/GeV, b[168]/GeV, b[169]/GeV, 
		      b[170]/GeV, b[171]/GeV, b[172]/GeV, b[173]/GeV, b[174]/GeV, b[175]/GeV, b[176]/GeV, b[177]/GeV, b[178]/GeV, b[179]/GeV, 
		      b[180]/GeV, b[181]/GeV, b[182]/GeV, b[183]/GeV, b[184]/GeV, b[185]/GeV, b[186]/GeV, b[187]/GeV, b[188]/GeV, b[189]/GeV, 
		      b[190]/GeV, b[191]/GeV, b[192]/GeV, b[193]/GeV, b[194]/GeV, b[195]/GeV, b[196]/GeV, b[197]/GeV, b[198]/GeV, b[199]/GeV, 
		      b[200]/GeV, b[201]/GeV, b[202]/GeV, b[203]/GeV, b[204]/GeV, b[205]/GeV, b[206]/GeV, b[207]/GeV, b[208]/GeV, b[209]/GeV, 
		      b[210]/GeV, b[211]/GeV, b[212]/GeV, b[213]/GeV, b[214]/GeV, b[215]/GeV, b[216]/GeV, b[217]/GeV, b[218]/GeV, b[219]/GeV, 
		      b[220]/GeV, b[221]/GeV, b[222]/GeV, b[223]/GeV, b[224]/GeV, b[225]/GeV, b[226]/GeV, b[227]/GeV, b[228]/GeV, b[229]/GeV, 
		      b[230]/GeV, b[231]/GeV, b[232]/GeV, b[233]/GeV, b[234]/GeV, b[235]/GeV, b[236]/GeV, b[237]/GeV, b[238]/GeV, b[239]/GeV, 
		      b[240]/GeV, b[241]/GeV, b[242]/GeV, b[243]/GeV, b[244]/GeV, b[245]/GeV, b[246]/GeV, b[247]/GeV, b[248]/GeV, b[249]/GeV, 
		      b[250]/GeV, b[251]/GeV, b[252]/GeV, b[253]/GeV, b[254]/GeV, b[255]/GeV, b[256]/GeV, b[257]/GeV, b[258]/GeV, b[259]/GeV, 
		      b[260]/GeV, b[261]/GeV, b[262]/GeV, b[263]/GeV, b[264]/GeV, b[265]/GeV, b[266]/GeV, b[267]/GeV, b[268]/GeV, b[269]/GeV, 
		      b[270]/GeV, b[271]/GeV, b[272]/GeV, b[273]/GeV, b[274]/GeV, b[275]/GeV, b[276]/GeV, b[277]/GeV, b[278]/GeV, b[279]/GeV, 
		      b[280]/GeV, b[281]/GeV, b[282]/GeV, b[283]/GeV, b[284]/GeV, b[285]/GeV, b[286]/GeV, b[287]/GeV, b[288]/GeV, b[289]/GeV, 
		       b[290]/GeV, b[291]/GeV, b[292]/GeV, b[293]/GeV, b[294]/GeV, b[295]/GeV, b[296]/GeV, b[297]/GeV, b[298]/GeV, b[299]/GeV,

		       /* 
		       v[0]/GeV, v[1]/GeV, v[2]/GeV, v[3]/GeV, v[4]/GeV, v[5]/GeV, v[6]/GeV, v[7]/GeV, v[8]/GeV, v[9]/GeV, v[10]/GeV, v[11]/GeV, 
		       v[12]/GeV, v[13]/GeV, v[14]/GeV, v[15]/GeV, v[16]/GeV, v[17]/GeV, v[18]/GeV, v[19]/GeV, h[0]/GeV,  h[1]/GeV,  h[2]/GeV, 
		        h[3]/GeV,  h[4]/GeV,  h[5]/GeV,  h[6]/GeV,  h[7]/GeV,  h[8]/GeV,  h[9]/GeV,  h[10]/GeV,  h[11]/GeV,  h[12]/GeV,  h[13]/GeV, 
		       h[14]/GeV,
		       */

		       v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8], v[9], v[10], v[11], 
		       v[12], v[13], v[14], h[0],  h[1],  h[2], 
		        h[3],  h[4],  h[5],  h[6],  h[7],  h[8],  h[9],  h[10],  h[11],  h[12],  h[13], 
		       h[14],



		      
		       totalEdep/GeV, diffX/cm, diffY/cm, diffZ/cm, 
		      fStartOut};

  ntuple->Fill(ntpars);

  /*
  fprintf(outfile, "%d\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t", 
	  evtIndex, vtxE/GeV, initX/cm, initY/cm, initZ/cm, 
	  initPX, initPY, initPZ, 
	  caloEdep/GeV);
  for(G4int bi=1; bi<=20; bi++){
    fprintf(outfile, "%f\t", b[bi-1]/GeV);
  }
  fprintf(outfile, "\n");
  */
}



G4int CaloSimSD::GetParticleType(G4String particleName,
                                       G4int parentID)
{
  if(!strcmp(particleName,"e+") && parentID == 1)
    {return 1;}
  else if(!strcmp(particleName,"e-"))    {return 2;}
  else if(!strcmp(particleName,"gamma")) {return 3;}
  else if(!strcmp(particleName,"mu+") && parentID == 0)   {return 4;}
  else if(!strcmp(particleName,"e+") && parentID > 1)
    {return 5;}
  else {return 6;}
}




